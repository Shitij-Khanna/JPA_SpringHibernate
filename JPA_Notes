-- Hibernate uses a sequence to insert values when inserting data with @generatedValue for ID.

-- Entity needs to have adefault constructor with no parameters

-- Entitymanager.flush would send all the changes at that point to the DB , i.e. the records updated till that point would be sent to DB even before the txn is committed

Under the @Transactional attribute, the object is under the purview of Entitymanager, so even after saving, like em.save(course),
if the course entity is updated, 
like course.setName("1"), this would be updated in the DB.
This is because the entity is attached to EM still , and any changes would be reflected in the DB.
To detach the entity from EM after saving the obj, use 
-- em.detach(course);

-- em.clear() -- this would clear everything that is attached to the Entitymanager
all objects being monitored by it would be detached

-- em.refresh() would read the latest value from DB

All entitied saved via Entitymanager are saved to PersistenceContext
This context keeps track of all entities updated / saved by EM.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------


JPQL :

JPQL queries are written using entities.
They interact with entities, internally converted to sql queries.

select c from course // course is our entity.
c is the alias for *.

With named query, u can give name to a query and use it later
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Relationships :
onetoOne
Student - Passport : 

If, passport object included in student class, then iby default it is loaded when student object is loaded, this is called EAGER FETCH.
By default, in one to one relationships, there is Eager fetch.
Even if you do not want to read the passport object by default, it would be fetched with student by default. This can result in performance issues, because passport would be fetched even if not required.

SLF4J: Failed toString() invocation on an object of type [org.hibernate.collection.internal.PersistentBag]

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Many to many relationship : 
When there is many to many reln,
it does not matter which side is the owning side of the relationship. We use join table

	// in many to many, there is no owning side of the relationship, so we can
	// define mapped by on any side
	// A separate join table is created with student id and course id mapping

reference is not stored in same tables, boc there can be multiple references to one object
Hence, a separate table is created to store both mappings.

After we define mappedby on any of the sides of many to many, the other one can then technically be called the owning side.
We can put the @jointable annotation there.
Using @jointable annotation, we can give the table our own name, (the table which contains mappings for all records of the many to many relationship).

Then we also specify the join column and the inverse join column.
In the joincolumn annotation, we will give the id of the owning side of the relationship, i.e studentid (coz student is the owning side if mapped by is defined in Course table).
In inverse join column annotation, the column which is specified is the column on the other side	

Many to many is lazy fetch by default
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
Hibernate : 
Create a session factory - single object per application
Session factory is a very heavy object and requires lots of resources, so it is loaded only once.
Create a session from the session factory.
Use the session to save the model objects

SessionFactory factory = new configuration().configure().buildSessionFactory("hibernate.cfg.xml");
Session session = factory.openSession();
session.beginTransaction();
session.save(modelObject);
session.getTransaction().commit();
session.close();

to read objects, open another session and get object from it
session = factory.openSession();
session.beginTransaction();
session.get(UserDetails.class, id);
session.close();

`
If you have @transient or @static property, it would not be persisted 
So if you dont want a field in the entity to be saved to DB, make it static or mark as @transient


----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Hibernate waits until the last point in the transaction before firing the queries
If we are using @Transactional, queries are inserted / fired at the end of the method's execution.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Inheritance in JPA : 

A.
@Inheritance(stratery = InheritanceType.SingleTable)
: default type
: When you define classes in inheritance way, 
like class Employee is parent abstract class, and class FullTimeEmployee and PartTimeEmployee extend that parent class, and all of these are @entity
Then if we want all the data from these entities to be persisted into the same table in the DB, we use this strategy.

Good for performance perspective, it is good because data can be fetched from one table.
But, data integegrity and management becomes difficult when there is lots of data, then there are lots of null values also.

An additional column gets added into the table, dType (discriminatory type), which defines which type of value it is, from both the child classes.

B. @Inheritance(stratery = InheritanceType.TablePerClass)
Here, there is a table for all the classes, not the abstract classes
So there is a table for all child classes, but the columns belonging to the parent class are present in all tables belonging to subclasses.
This would mean duplicate data in many cases.

To fetch data from all tables,
a union is executed in all tables.
From performance point of view it is good still, but data duplicacy is lot.

C. @Inheritance(stratery = InheritanceType.JOINED)
Parent class will have its own table
Sub classes have their own table
Common data is saved in parent table
Specific data for all subclasses is saved in their own tables, also a column (like id), as a foreign key from the parent table to help in joins.
to retreive data joins are executed.

this is really good in terms of DB design, but from performance it is not very good, as their are joins executed to fetch data and when there are lots of tables it would become really big.

D. @MappedSuperClass
Put this to the parent class.
NOTE : @MappedSuperClass cannot be an entity
No table exists for the mapped superclass.
So, you cannot query on the parent class using it's entity name.
You can only query on the child classes, which have entities.

Actually, there is not inheritance between the tables here.
There is just some common data between the 2 tables.










